{
  "array type": {
    "prefix": "a",
    "body": [
      "${1:T}[]${0}"
    ],
    "description": "array type declaration"
  },
  "Dictionary<TKey, TValue> variable (with initializer)": {
    "prefix": "vd_",
    "body": [
      "var ${1:dic} = new Dictionary<${2:object}, ${3:object}>() { [0] = ${4:null} };${0}"
    ],
    "description": "Dictionary<TKey, TValue> variable declaration (with initializer)"
  },
  "Dictionary<TKey, TValue> variable": {
    "prefix": "vd",
    "body": [
      "var ${1:dic} = new Dictionary<${2:object}, ${3:object}>();${0}"
    ],
    "description": "Dictionary<TKey, TValue> variable declaration"
  },
  "HashSet<T> type": {
    "prefix": "ghs",
    "body": [
      "HashSet<${1:T}>${0}"
    ],
    "description": "HashSet<T> type declaration"
  },
  "HashSet<T> variable": {
    "prefix": "vhs",
    "body": [
      "var ${1:items} = new HashSet<${2:T}>();${0}"
    ],
    "description": "HashSet<T> variable declaration"
  },
  "HashSet<T> variable (with initializer)": {
    "prefix": "vhs_",
    "body": [
      "var ${1:items} = new HashSet<${2:T}>() { ${3:null} };${0}"
    ],
    "description": "HashSet<T> variable declaration (with initializer)"
  },
  "List<T> type": {
    "prefix": "gl",
    "body": [
      "List<${1:T}>${0}"
    ],
    "description": "List<T> type declaration"
  },
  "List<T> variable": {
    "prefix": "vl",
    "body": [
      "var ${1:items} = new List<${2:T}>();${0}"
    ],
    "description": "List<T> variable declaration"
  },
  "List<T> variable (with initializer)": {
    "prefix": "vl_",
    "body": [
      "var ${1:items} = new List<${2:T}>() { ${3:null} };${0}"
    ],
    "description": "List<T> variable declaration (with initializer)"
  },
  "new array ": {
    "prefix": "na",
    "body": [
      "new ${1:T}[${2:0}]${0}"
    ],
    "description": "new array "
  },
  "new array (with initializer)": {
    "prefix": "na_",
    "body": [
      "new ${1:T}[] { ${2:null} }${0}"
    ],
    "description": "new array (with initializer)"
  },
  "ObservableCollection<T> type": {
    "prefix": "goc",
    "body": [
      "ObservableCollection<${1:T}>${0}"
    ],
    "description": "ObservableCollection<T> type declaration"
  },
  "ObservableCollection<T> variable": {
    "prefix": "voc",
    "body": [
      "var ${1:items} = new ObservableCollection<${2:T}>();${0}"
    ],
    "description": "ObservableCollection<T> variable declaration"
  },
  "ObservableCollection<T> variable (with initializer)": {
    "prefix": "voc_",
    "body": [
      "var ${1:items} = new ObservableCollection<${2:T}>() { ${3:null} };${0}"
    ],
    "description": "ObservableCollection<T> variable declaration (with initializer)"
  },
  "break statement": {
    "prefix": "bk",
    "body": [
      "break;${0}"
    ],
    "description": "break statement"
  },
  "?: operator (equal to null)": {
    "prefix": "con",
    "body": [
      "(${1:expression} == null) ? ${2:null} : ${3:null}${0}"
    ],
    "description": "?: (conditional) operator with condition whether the expression is equal to null"
  },
  "?: operator (not equal to null)": {
    "prefix": "conn",
    "body": [
      "(${1:expression} != null) ? ${2:null} : ${3:null}${0}"
    ],
    "description": "?: (conditional) operator with condition whether the expression is not equal to null"
  },
  "continue statement": {
    "prefix": "ce",
    "body": [
      "continue;${0}"
    ],
    "description": "continue statement"
  },
  "Debug.Assert != null": {
    "prefix": "dann",
    "body": [
      "Debug.Assert(${1:false} != null, ${2:\"\"});${0}"
    ],
    "description": "Debug.Assert method with condition whether the expression is not equal to null"
  },
  "Dictionary<TKey, TValue> type": {
    "prefix": "gd",
    "body": [
      "Dictionary<${1:object}, ${2:object}>${0}"
    ],
    "description": "Dictionary<TKey, TValue> type declaration"
  },
  "do while not null": {
    "prefix": "donn",
    "body": [
      "do",
      "{",
      "    ${0}",
      "",
      "} while (${1:x} != null);"
    ],
    "description": "do statement with condition whether an expression is not equal to null"
  },
  "do while null": {
    "prefix": "don",
    "body": [
      "do",
      "{",
      "    ${0}",
      "",
      "} while (${1:x} == null);"
    ],
    "description": "do statement with condition whether an expression is equal to null"
  },
  "if Enum.TryParse": {
    "prefix": "ifemtp",
    "body": [
      "${1:TEnum} ${2:x};",
      "if (Enum.TryParse(${3:value}, out ${2}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if statement with condition whether Enum.TryParse method returns true."
  },
  "if not Enum.TryParse": {
    "prefix": "iffemtp",
    "body": [
      "${1:TEnum} ${2:x};",
      "if (!Enum.TryParse(${3:value}, out ${2}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if statement with condition whether Enum.TryParse method returns false."
  },
  "if !string.IsNullOrEmpty": {
    "prefix": "iffsne",
    "body": [
      "if (!string.IsNullOrEmpty(${1:s}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if !string.IsNullOrEmpty"
  },
  "if !string.IsNullOrWhiteSpace": {
    "prefix": "iffsnw",
    "body": [
      "if (!string.IsNullOrWhiteSpace(${1:s}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if !string.IsNullOrWhiteSpace"
  },
  "if string.IsNullOrEmpty": {
    "prefix": "ifsne",
    "body": [
      "if (string.IsNullOrEmpty(${1:s}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if string.IsNullOrEmpty"
  },
  "if string.IsNullOrWhiteSpace": {
    "prefix": "ifsnw",
    "body": [
      "if (string.IsNullOrWhiteSpace(${1:s}))",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "if string.IsNullOrWhiteSpace"
  },
  "lambda expression with 2 parameters": {
    "prefix": "l2",
    "body": [
      "(${1:f}, ${2:g}) => ${0}"
    ],
    "description": "lambda expression with 2 parameters"
  },
  "namespace": {
    "prefix": "ns",
    "body": [
      "namespace ${1:NamespaceName}",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "namespace declaration"
  },
  "Regex type": {
    "prefix": "rx",
    "body": [
      "Regex${0}"
    ],
    "description": "Regex type declaration"
  },
  "return new": {
    "prefix": "rn",
    "body": [
      "return new${0}"
    ],
    "description": "return new"
  },
  "return new containing type": {
    "prefix": "rnthis",
    "body": [
      "return new ${1:ThisName}${0}"
    ],
    "description": "return new containing type"
  },
  "return statement": {
    "prefix": "re",
    "body": [
      "return;${0}"
    ],
    "description": "return statement"
  },
  "StringBuilder variable": {
    "prefix": "vsb",
    "body": [
      "var ${1:sb} = new StringBuilder();${0}"
    ],
    "description": "StringBuilder variable declaration"
  },
  "throw statement": {
    "prefix": "tw",
    "body": [
      "throw;${0}"
    ],
    "description": "throw statement"
  },
  "TimeSpan type": {
    "prefix": "ts",
    "body": [
      "TimeSpan${0}"
    ],
    "description": "TimeSpan type declaration"
  },
  "variable declaration with as operator + if not null": {
    "prefix": "vasnn",
    "body": [
      "var ${1:x} = ${2:expression} as ${3:T};",
      "if (${1} != null)",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "variable declaration with as operator + condition whether the variable is not equal to null"
  },
  "while not null": {
    "prefix": "wenn",
    "body": [
      "while (${1:x} != null)",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "while statement with condition whether an expression is not equal to null"
  },
  "while null": {
    "prefix": "wen",
    "body": [
      "while (${1:x} == null)",
      "{",
      "    ${0}",
      "}"
    ],
    "description": "while statement with condition whether an expression is equal to null"
  },
  "yield return new": {
    "prefix": "yrn",
    "body": [
      "yield return new${0}"
    ],
    "description": "yield return new"
  },
  "yield return new containing type": {
    "prefix": "yrnthis",
    "body": [
      "yield return new ${1:ThisName}${0}"
    ],
    "description": "yield return new containing type"
  }
}